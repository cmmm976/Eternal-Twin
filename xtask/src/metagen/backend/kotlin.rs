use crate::metagen::core::{DisplayMgName, LowerSnake, MgType, PascalCase, TypeRegistry};
use std::fmt;
use std::path::PathBuf;

pub struct KotlinBackend {
  /// Root directory (e.g. `app/src/main/kotlin`)
  pub root: PathBuf,
  /// All the types will be in this group (package)
  pub group: Vec<String>,
}

impl KotlinBackend {
  pub fn new(root: PathBuf, group: Vec<String>) -> Self {
    Self { root, group }
  }
}

impl KotlinBackend {
  pub fn emit(&self, reg: &TypeRegistry) -> Result<(), anyhow::Error> {
    for (path, typ) in reg.paths() {
      let class_name = path.type_name().display::<PascalCase>();
      let mut package_name = self.group.clone();
      package_name.extend(path.group_names().iter().map(|n| n.display::<LowerSnake>().to_string()));
      let mut file = self.root.clone();
      file.extend(package_name.iter());
      let file = file.join(format!("{}.kt", class_name));
      let package_name = package_name.join(".");
      let full_class_name = format!("{}.{}", package_name, class_name);
      let file_content = match typ {
        MgType::String => todo!(),
        MgType::Unique(_, inner) => match inner.as_ref() {
          MgType::String => {
            let content = KotlinNewString {
              package: &package_name,
              class_name,
              full_class_name: &full_class_name,
            };
            content.to_string()
          }
          MgType::Unique(_, _) => todo!(),
        },
      };
      std::fs::write(file, file_content)?;
    }
    Ok(())
  }
}

struct KotlinNewString<'typ> {
  package: &'typ str,
  class_name: DisplayMgName<'typ, PascalCase>,
  full_class_name: &'typ str,
}

impl<'typ> fmt::Display for KotlinNewString<'typ> {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(
      f,
      r#"// WARNING: DO NOT EDIT THE FILE MANUALLY!
// This file was auto-generated by `cargo xtask kotlin` from the definitions in `xtask/src/metagen/etwin.rs`.

package {package}

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

@Serializable(with = {class_name}.Serializer::class)
data class {class_name}(
  val inner: String,
) {{
  fun toDebugString(): String = "{class_name}(${{this}})"

  override fun toString(): String = this.inner

  object Serializer : KSerializer<{class_name}> {{
    override val descriptor: SerialDescriptor =
      PrimitiveSerialDescriptor("{full_class_name}", PrimitiveKind.STRING)

    override fun serialize(encoder: Encoder, value: {class_name}) =
      encoder.encodeString(value.inner)

    override fun deserialize(decoder: Decoder): {class_name} =
      {class_name}(decoder.decodeString())
  }}
}}
"#,
      package = self.package,
      class_name = self.class_name,
      full_class_name = self.full_class_name,
    )
  }
}
